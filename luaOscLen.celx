function flash(message)
   celestia:flash(message)
   wait(0)
end

celestia:requestsystemaccess()
wait(0)

local socket = require("socket")
local osc = require("osc")
local math = require("math")

-- server

udp = socket.udp()
udp:setsockname("*", 8000)
udp:settimeout(0)

-- client (todo - data entry for client address?)

-- state vars

speed_multi = 1

left_rot_step = math.rad(-90) / 50
right_rot_step = math.rad(90) / 50

-- server main loop

while true do

    data = udp:receive(4096)
    if data then
        url, intx, inty = osc.unpack(data)

        -- handle manual x/y control
        if url == "/cel/xy1" then
          obs = celestia:getobserver()
          x_vector = celestia:newvector(1,0,0)
          y_vector = celestia:newvector(0,1,0)
          rot = celestia:newrotation(x_vector, math.rad(intx / 360))
          obs:rotate(rot)
          rot = celestia:newrotation(y_vector, math.rad(inty / 360))
          obs:rotate(rot)
          flash("osc: " .. url .. " --> " .. intx .. "/" .. inty)
        end

        -- speed control
        if url == "/cel/speed" then
          uly_to_km = 9460730.4725808
          obs = celestia:getobserver()
          obs:setspeed(intx/uly_to_km)
          flash("osc: " .. url .. " --> " .. intx)
        end

        -- speed multi
        if url == "/cel/speed_multi" then
          speed_multi = intx
          flash("osc: " .. url .. " --> " .. intx)
        end

        -- speed multi
        if url == "/cel/speed_multi" then
          speed_multi = intx
          flash("osc: " .. url .. " --> " .. intx)
        end

        -- speed multi
        if url == "/cel/speed_multi" then
          speed_multi = intx
          flash("osc: " .. url .. " --> " .. intx)
        end
        
    end
    socket.sleep(0.01)
    wait(0)

end
