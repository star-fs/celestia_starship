function flash(message)
   celestia:flash(message)
   wait(0)
end

celestia:requestsystemaccess()
wait(0)

local socket = require("socket")
local osc = require("osc")
local math = require("math")
local table = require("table")

local posix = require 'posix'
local timersub, gettimeofday = posix.timersub, posix.gettimeofday

-- server
udp = socket.udp()
udp:setsockname("*", 8000)
udp:settimeout(0)

-- state vars
local planets = {}

local jump_coords = {x = 0, y = 0, z = 0}

local speed_multi = 1

local left_rot_step = math.rad(90) / 30
local right_rot_step = math.rad(-90) / 30

local do_left = 0
local do_right = 0

local x_vector = celestia:newvector(1,0,0)
local y_vector = celestia:newvector(0,1,0)
local z_vector = celestia:newvector(0,0,1)

local uly_to_km = 9460730.4725808

-- functions 
 
function visit_planets (vplanets)
  for k,v in pairs(vplanets) do

    if v == "sol" then 
      planet = celestia:find("Sol")
    else
      planet = celestia:find("Sol/" .. v)
    end

    obs = celestia:getobserver()
    obs:setframe(celestia:newframe("universal"))

    celestia:select(planet)
    obs:goto(planet, 10.0)
    name = planet:name()
    info_table = planet:getinfo()

    --[[
    out = ""

    if name then
      out = out .. "---- Planet " .. name .. " ----\n"
    end
    if info_table.type then
      out = out .. "Type: " .. info_table.type .. "\n"
    end
    if info_table.name then
      out = out .. "Name: " .. info_table.name .. "\n"
    end
    if info_table.oblateness then
      out = out .. "Oblateness: " .. info_table.oblateness .. "\n"
    end
    if info_table.albedo then
      out = out .. "Albedo: " .. info_table.albedo .. "\n"
    end
    if info_table.radius then
      out = out .. "Radius: " .. info_table.radius .. "\n"
    end
    if info_table.lifespanStart then
      out = out .. "Lifespan Start: " .. info_table.lifespanStart .. "\n"
    end
    if info_table.lifespanEnd then
      out = out .. "Lifespan End: " .. info_table.lifespanEnd .. "\n"
    end
    if info_table.rotationPeriod then
      out = out .. "Rotation Period: " .. info_table.rotationPeriod .. "\n"
    end
    if info_table.orbitPeriod then
      out = out .. "orbit Period: " .. info_table.orbitPeriod .. "\n"
    end

    celestia:print(out, 20.0, -1, -1, 2, 25)
    --]]
    wait(10.0)
  end
  return {}
end

local function isempty(s)
  return s == nil or s == ''
end

-- http://stackoverflow.com/questions/1426954/split-string-in-lua
function split(pString, pPattern)
   if #pString == 0 then
    return ""
   end
   local Table = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pPattern
   local last_end = 1
   local s, e, cap = pString:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
      table.insert(Table,cap)
      end
      last_end = e+1
      s, e, cap = pString:find(fpat, last_end)
   end
   if last_end <= #pString then
      cap = pString:sub(last_end)
      table.insert(Table, cap)
   end
   return Table
end

function toInt(s) 
  return tonumber(s) or (s == "" and 0) or error("expected number string, got " .. s .. " type of:" ..type(s)) 
end 

-- server main loop

jmpx = 0
jmpy = 0
jmpz = 0

client_ip = ""
client_port = 9000

time_from_last = gettimeofday()

while true do

    data, client_ip, send_port = udp:receivefrom(4096)

    now = gettimeofday()
    elapsed = timersub(now, time_from_last)
    elapsed_in_ms = elapsed.sec * 1000 + elapsed.usec / 1000

    if elapsed_in_ms < 200 then
      -- data = false
    else 
      time_from_last = gettimeofday()
    end

    -- flash(elapsed_in_ms)

    if data then
       
        obs = celestia:getobserver()
        obs:setframe(celestia:newframe("universal"))

        url, intx, inty = osc.unpack(data)

        if inty then
          flash("osc: " .. url .. " --> " .. intx .. "/" .. inty)
        else
          if intx then
            flash("osc: " .. url .. " --> " .. intx)
          else 
            intx = 0
          end
        end

        -- handle manual x/y control
        if url == "/cel/xy1" then
          rot = celestia:newrotation(x_vector, math.rad(intx / 90))
          obs:rotate(rot)
          rot = celestia:newrotation(y_vector, math.rad(inty / 90))
          obs:rotate(rot)

          -- reset display
          socket.udp():sendto(osc.pack('/cel/xy1', 0, 0), client_ip, client_port)

        end

        -- speed control
        if url == "/cel/speed" then
          uly_to_km = 9460730.4725808
          obs:setspeed((intx * speed_multi)/uly_to_km)
        end

        -- speed multi
        if string.find(url, "/cel/smulti/") then
          url_parts = split(url, "/")
          speed_multi = toInt(url_parts[3])
          if speed_multi == 1 then
            speed_multi = 0.001
          end
          if speed_multi == 2 then
            speed_multi = 1
          end
          if speed_multi == 3 then
            speed_multi = 5
          end
          if speed_multi == 4 then
            speed_multi = 10
          end
          if speed_multi == 5 then
            speed_multi = 100
          end
        end 

        -- rotate left
        if url == "/cel/rot_l" then
          do_left = intx
        end

        -- rotate right
        if url == "/cel/rot_r" then
          do_right = intx
        end
  
        -- set planet state
        if string.find(url, "/cel/nav/") and not string.find(url, "jmp") and not string.find(url, "jump") then
          if intx == 1 then
            if url ~= "/cel/nav/event/go" then
              url_parts = split(url, "/")
              flash("scheduling trip to:" .. url_parts[3])
              planets[#planets + 1] = url_parts[3]

              -- display target info
              uly_to_km = 9460730.4725808

              -- Set frame of reference to "universal"
              obs = celestia:getobserver()
              obs:setframe(celestia:newframe("universal"))

              -- Find and select target
              targ = celestia:find("Sol/" .. url_parts[3])
              celestia:select(targ)

              -- print actual position of target
              tnow = celestia:gettime()
              pos = targ:getposition(tnow)
              pos_x = pos:getx()
              pos_y = pos:gety()
              pos_z = pos:getz()

              celestia:print(
                "Actual position of " .. url_parts[3] .. ":\nX = " .. pos_x .. 
                "\nY = " .. pos_y .. "\nZ = " ..  pos_z, 15, -1, -1, 1, 6
              )

            else 
              flash("starting autopilot ... ")
              visit_planets(planets)
              planets = {}
            end
          end
        end

        -- handle label events (aka nav aids)
        if string.find(url, "/cel/disp/") then
          url_parts = split(url, "/")
          if intx == 1 then
            celestia:show(url_parts[3])
          else 
            celestia:hide(url_parts[3])
          end
        end

        -- inc/dec x/y/z for hyperspace jump
        if string.find(url, "/cel/jnav/jmp") then

          if intx == 1 then
            url_parts = split(url, "/")
            target_parts = split(url_parts[3], "_")

            if target_parts[3] == "inc" then
              -- increment coord value
              jump_coords[target_parts[2]] = jump_coords[target_parts[2]] + 1
            else
              -- decrement coord value
              jump_coords[target_parts[2]] = jump_coords[target_parts[2]] - 1
            end

            -- update display
            disp_url = '/cel/nav/' .. target_parts[1] .. target_parts[2]
            socket.udp():sendto(osc.pack(disp_url, jump_coords[target_parts[2]]), client_ip, client_port)

          end
        end

        -- perform hyperspace jump
        if url == '/cel/nav/jump' and intx == 1 then

          pos = celestia:newposition((jump_coords['x'] + (20000/uly_to_km)), jump_coords['y'], jump_coords['z'])
          obs:goto(pos, 3.0)

          -- wait for "jump" to complete
          wait(3.0)

        end

    -- end if data
    end

    if do_left ~= 0 then
      rot = celestia:newrotation(z_vector, (left_rot_step * intx))
      obs:rotate(rot)
      wait(0)
    end

    if do_right ~= 0 then
      rot = celestia:newrotation(z_vector, (right_rot_step * intx))
      obs:rotate(rot)
      wait(0)
    end

    -- socket.sleep(0.01)
    wait(0)

end
